\chapter{Estado del arte}\label{chap:state-of-the-art}
% TODO:
% - RISCV/ARM/MIPS
% - Ensambladores
%   - GNU as/intel (no estandarizado)/TCCASM
% - WASM/JS
% - NPM/cargo

\section{Simuladores de ensamblador}

Un simulador de \glsdisp{assembly}{ensamblador} es un \gls{program} que permite
simular la ejecución de un \gls{program} escrito en \glsdisp{assembly}{ensamblador},
simulando el comportamiento de un \gls{processor} que ejecuta el código. Suelen
tener un propósito didáctico, para ayudar al usuario a aprender el
funcionamiento del lenguaje y el \gls{processor}, aunque algunos también se
pueden utilizar de forma profesional para desarrollar una nueva \gls{ISA}.

Estos simuladores están compuestos de dos componentes principales: un
\gls{assembler} y un ejecutor. El \gls{assembler} se encarga de procesar el
código \glsdisp{assembly}{ensamblador} introducido por el usuario a un formato
que pueda ser utilizado por el simulador, mientras que el ejecutor se encarga
de ejecutar el código generado por el \gls{assembler} en el \gls{processor}
simulado. Los simuladores se pueden clasificar en específicos, si estos componentes
solo permiten simular una \gls{ISA} específica, o genéricos, si se pueden
configurar para simular varias \glspl{ISA} distintas.

\subsection{Simuladores específicos}

Un simulador específico está diseñado para simular una única \gls{ISA}, como
RISC-V o ARM, y no permite su modificación. Esto hace que sean más simples que
los simuladores genéricos, y, debido a esto, la mayoría de los simuladores en la
actualidad entran dentro de esta categoría.

\subsubsection{Spike}

Spike \parencite{spike} es el simulador de referencia para RISC-V, desarrollado
por RISC-V International. Es capaz de emular un sistema RISC-V completo, y está
diseñado para servir como un punto de inicio para ejecutar código RISC-V.

Spike cuenta con una interfaz por \glsdisponly{CLI}{línea de comandos}, y
permite seleccionar las extensiones de la \gls{ISA} (contando con soporte para
la mayoría de las extensiones estándar) y el modelo de memoria a utilizar.
Permite ejecutar código \gls{instruction} a \gls{instruction}, visualizar el
contenido de los \glspl{register} y la \gls{memory}, y ejecutar código en modo
usuario y privilegiado. También cuenta con un modo de depuración interactivo, y
permite utilizar \progref{gdb} para esto. Aunque es un simulador específico de
RISC-V, permite añadir y probar nuevas \glspl{instruction}.

% TODO:
% \graphicfigure{spike}{Interfaz de Spike}

% TODO: add another simulator

\subsection{Simuladores genéricos}

Un simulador genérico permite simular varias \glspl{ISA} distintas. Esto añade
bastante complejidad a su diseño, ya que los componentes necesitan soportar
muchas opciones de configuración distintas para permitir especificar la
\gls{ISA}. En esta sección se exponen dos ejemplos de este tipo de simuladores:
Sail y CREATOR.

\subsubsection{Sail}

Sail \parencite{sail} es un lenguaje para definir la \gls{ISA} de un
\gls{processor} desarrollado por la Universidad de Cambridge.

Esta herramienta permite validar la definición de la \gls{ISA} y generar
simuladores en C y OCaml. Además, también permite ejecutar pruebas de validación
y generar versiones de la \gls{ISA} que se pueden ejecutar con un \gls{theorem
prover} para realizar demostraciones sobre el comportamiento de la \gls{ISA}.
Actualmente, está en desarrollo un componente para generar un modelo de
referencia en un lenguaje de descripción de \textit{hardware}. Todas estas
características lo hacen una muy buena opción para el uso profesional, aunque
esto también lo vuelve una mala opción para el uso didáctico debido a su gran
complejidad.

\subsubsection{CREATOR}

CREATOR (didaCtic and geneRic assEmbly progrAmming simulaTOR)
\parencite{CREATOR} es un simulador didáctico desarrollado por el grupo de
investigación ARCOS de la Universidad Carlos III de Madrid. Tiene tanto una
versión web como una versión de \gls{CLI}, y se desarrolló para ayudar a los
estudiantes a aprender el \gls{assembly} en la asignatura de Estructura de
Computadores.

CREATOR cuenta con un editor de código con resaltado de sintaxis para escribir
el código \glsdisp{assembly}{ensamblador}, y una interfaz que permite ver el
estado del \gls{processor} (\glspl{register} de control, enteros y de coma
flotante) y la \gls{memory} (\gls{data memory}, \gls{text memory}, y
\textit{stack}), las \glspl{instruction} cargadas, y diversas estadísticas sobre
la ejecución del \gls{program}. Tiene soporte para la ejecución
\gls{instruction} a \gls{instruction}, I/O, llamadas al sistema,
\textit{breakpoints}, y convención de paso de parámetros.

Con respecto a la modificación de la \gls{ISA}, CREATOR es muy flexible. Permite
modificar la arquitectura del procesador (\glspl{register} definidos y su
nombre, tipo, tamaño y diferentes propiedades), la organización de la
\gls{memory}, y las \glspl{instruction}, \glspl{pseudo-instruction}, y
\gls{directive} permitidas en el código. Con respecto a las \glspl{instruction}
y \glspl{pseudo-instruction}, permite definir su nombre, sintaxis, argumentos y
la codificación de estos en binario, tamaño, número de ciclos para su ejecución,
y su definición, ya sea las acciones a realizar durante su ejecución para las
\glspl{instruction} o la secuencia de \glspl{instruction} por la que
reemplazarla para las \glspl{pseudo-instruction}. Todo esto se realiza mediante
un fichero de configuración en formato \gls{json}, permitiendo el uso de
\gls{JS} para ciertas opciones como la ejecución de una \gls{instruction}.
Utilizando esto, CREATOR cuenta con definiciones para RISC-V y MIPS.

La principal limitación de CREATOR es su \gls{assembler}. Aunque permite
procesar \glspl{program} simples, carece de muchas funcionalidades importantes
como el uso de etiquetas en las \glspl{data directive}. Esto es necesario, por
ejemplo, para la creación del vector de interrupciones utilizado por los
sistemas operativos para gestionar los diversos tipos de interrupciones. Además,
sus mensajes de error son mejorables, y a veces no son capaces de mostrar el
problema real. El sistema a desarrollar se encargará de reemplazar a este
\gls{assembler}, solucionando todos estos problemas.

% TODO:
% \graphicfigure{creator}{Interfaz principal de CREATOR}

\section{Lenguajes de programación}

Actualmente, las herramientas utilizadas durante el desarrollo de
\textit{software} para los diversos lenguajes, como \glspl{compiler},
\glspl{formatter}, o \glspl{linter}, se implementan en muchos lenguajes de
programación distintos.

Para los lenguajes de bajo nivel, como C \parencite{C} y C++ \parencite{cpp} o
\glsdisp{assembly}{ensamblador}, típicamente las herramientas se implementan en
lenguajes de bajo nivel, comúnmente el mismo para el que se utilizan. Esto es
debido a su mayor rendimiento, ya que el \textit{software} realizado en estos
lenguajes sule tener grandes bases de código. La mayoría de herramientas de
estos lenguajes, como \progref{gcc} y la \textit{suite} de \verb!clang!
(\verb!clang!, \verb!clang-tidy! y \verb!clang-format!) \parencite{clang},
utilizan C/C++. Una excepción importante a esto es \progref{conan}, el gestor de
paquetes de C/C++, que está escrito en un lenguaje de alto nivel (Python).

En los lenguajes de alto nivel, como Python \parencite{Python} o \gls{TS}
\parencite{typescript}, las herramientas tradicionalmente se han implementado en
lenguajes de alto nivel para facilitar su desarrollo. Este es el caso de
\progref{pylint}, \progref{black} o el \gls{compiler} de \gls{TS}
\parencite{tsc}. Sin embargo, recientemente muchas de estas herramientas se
están reescribiendo en lenguajes de más bajo nivel como Rust \parencite{Rust} o
Go \parencite{Go} debido a la mejora significativa de rendimiento que ofrecen
estos lenguajes \parencite{typescript-go}. Algunos ejemplos de herramientas que
han tenido éxito con esto son \progref{ruff} y \progref{uv}.

\section{Mensajes de error}

En la actualidad, los mensajes de error de los \gls{compiler} tienen muchas
formas y calidades. Un \gls{compiler} con buenos mensajes de error puede ayudar
mucho a solucionar los problemas más rápidamente, ya que permite obtener toda la
información necesaria para solucionar el problema del propio mensaje de error.

Un ejemplo de malos mensajes de error es el \gls{compiler} de C\#, cuyos mensajes
de error se pueden ver en la \figureref{error_csharp}. Como se puede ver, estos
mensajes contienen muy poca información sobre el problema. Esto dificulta
corregir los errores, especialmente para alguien que está intentando aprender el
lenguaje.

\graphicfigure[0.9]{error_csharp}{Mensaje de error del compilador de C\#}

Actualmente, el compilador de Rust \parencite{Rust} es uno de los
compiler que mejores mensajes de error genera. La \figureref{error_rust}
muestra un ejemplo de estos mensajes, obtenido en un caso de uso real. Como se
puede observar, este mensaje cuenta con varios componentes importantes:

\begin{itemize}
    \item Un mensaje de error con una explicación clara del error.
    \item La localización en el código que ha producido el fallo.
    \item Información adicional sobre el error y su causa, resaltada sobre el
    propio código.
    \item Un mensaje de ayuda que indica una posible solución del error,
    incluyendo una explicación y las modificaciones necesarias resaltadas sobre
    el código.
    \item Una forma de acceder a una explicación detallada sobre el problema.
\end{itemize}

Además de esto, la información está resaltada con diversos colores e indicadores
y se deja cierto espacio en blanco para separar las diferentes partes, lo cual
ayuda a leer rápidamente la información más importante para solucionar el
problema y filtrar la que no se necesita.

\graphicfigure[0.9]{error_rust}{Mensaje de error del compilador de Rust}

\FloatBarrier

\section{Técnicas de análisis sintáctico}\label{sec:parser-techniques}

Un \gls{compiler} se compone principalmente de dos partes: análisis sintáctico y
análisis semántico. El análisis sintáctico (\textit{parsing}) se encarga de
transformar el código a una representación intermedia, mientras que el análisis
semántico se encarga de, utilizando la representación intermedia, verificar que
el \gls{program} cumple la semántica del lenguaje y generar el código compilado.
\parencite{dragon-book}

Al tratar con la semántica del lenguaje, no existen técnicas generales para
realizar el análisis semántico. Sin embargo, para realizar el análisis
sintáctico, existen múltiples técnicas basadas en el uso de \glspl{grammar}
libres de contexto. Una \gls{grammar} es una descripción formal de la sintaxis
de un lenguaje, y está formada por: \parencite{dragon-book}

\begin{itemize}
    \item Un conjunto de símbolos terminales (también conocidos como
    \glspl{token}), que representan los símbolos que pueden aparecer en las
    cadenas del lenguaje.
    \item Un conjunto de símbolos no terminales, que representan estructuras
    sintácticas del lenguaje (conjuntos de cadenas).
    \item Un símbolo no terminal denominado axioma, que representa todas las
    cadenas del lenguaje.
    \item Un conjunto de producciones, que representan las reglas según las
    cuales un símbolo no terminal se puede reemplazar por una secuencia de
    símbolos terminales y/o no terminales.
\end{itemize}

Una gramática genera cadenas de caracteres aplicando las producciones a una
secuencia de símbolos, empezando por el axioma y continuando hasta que la
secuencia de símbolos solo contenga símbolos terminales. Este proceso se puede
representar con un árbol síntáctico, en el cual los nodos representan símbolos
(siendo la raíz el axioma, los \glspl{internal node} símbolos no terminales, y
las \glsdisp{leaf node}{hojas} símbolos terminales), y las relaciones entre un
nodo y sus hijos representan la aplicación de una producción determinada. La
tarea de un analizador sintáctico (\gls{parser}) consiste en determinar el árbol
sintáctico que produce la cadena de entrada. \parencite{dragon-book}

Las técnicas para realizar el análisis sintáctico se pueden agrupar en dos
grandes familias: análisis descendence (\textit{top-down}) y análisis ascendente
(\textit{bottom-up}). La diferencia entre estas familias está en cómo generan el
árbol sintáctico. Un analizador descendente empieza por la raíz (axioma) y
determina las producciones que se tienen que aplicar para obtener la cadena de
entrada, realizando una búsqueda en profundidad. Un analizador ascendente, en
cambio, empieza con los nodos hoja del árbol y determina cómo agruparlos en
símbolos no terminales siguiendo las producciones hasta llegar a la raíz.
\parencite{dragon-book}

\subsection{Análisis descendente}

Dentro de los analizadores descendentes, la técnica más general y utilizada es
el análisis descendente recursivo, que consiste en un \gls{program} que modela la
\gls{grammar} mediante un conjunto de funciones mutuamente recursivas, cada una
de las cuales representa un símbolo no terminal. Analizando la \gls{grammar}, se
puede crear un analizador predictivo en el cual el siguiente símbolo de la
entrada a procesar permite determinar sin ambigüedades el flujo de control en
cada función. \parencite{dragon-book}

Gracias a su sencillez, esta técnica típicamente se implementa a mano, aunque
también existen herramientas como ANTLR \parencite{ANTLR} que permiten generar
un analizador automáticamente a partir de una \gls{grammar} (conocido como
generador de \glspl{parser} \parencite{dragon-book}).

También existen otros métodos para crear analizadores descendentes
recursivos a partir de una \gls{grammar}, como los combinadores de
\glspl{parser}. Este método consiste en definir un analizador sintáctico como
combinación de otros \glspl{parser} más simples, utilizando diversos operadores
que permiten realizar combinaciones muy expresivas
\parencite{parser-combinators}. En la actualidad, existen muchas bibliotecas que
cuentan con estos operadores ya implementados, como Parsec \parencite{parsec}, Chumsky
\parencite{chumsky}, y pom \parencite{pom}.

% TODO: maybe mention resilient LL parsing?
La principal ventaja de crear un analizador descendente recursivo manualmente es su
gran flexibilidad, ya que ofrece control total sobre el funcionamiento del
analizador sintáctico. Esto permite utilizar información obtenida durante la
ejecución del \gls{compiler} para decidir cómo procesar la entrada, permitiendo
un cierto grado de sensibilidad al contexto. Además, esto ayuda a generar buenos
mensajes de error y a aplicar estrategias de recuperación de errores
\parencite{errors-clang}. Muchos de los \glspl{programming language} utilizados
en la actualidad, como C y C++, utilizan este método
\parencite{parser-types-survey}.

El principal problema de crear un analizador descendente recursivo a mano es su
complejidad, requiriendo mucho tiempo para su desarrollo, además de que las
modificaciones de la \gls{grammar} también son complicadas. Los combinadores de
\glspl{parser}, en cambio, facilitan mucho estos procesos, aunque sacrifican un
poco de rendimiento para lograrlo. Esto hace que los combinadores de
\glspl{parser} sean un método ideal para realizar prototipos, durante los cuales
la \gls{grammar} puede variar, mientas que crear un analizador manualmente es
una mejor opción para un producto final cuando el rendimiento se vuelve un
problema.

Estas técnicas, en general, son muy efectivas. Sin embargo, para \glspl{grammar}
que cumplen ciertas propiedades (\glspl{operator-precedende grammar}) típicas de
\gls{expression} aritméticas, especialmente cuando cuentan con muchos niveles de
precedencia, existen técnicas más eficientes. Estas técnicas se pueden agrupar
en los \gls{parser} de precedencia de operadores
\parencite{operator-precedence-parser}. Un ejemplo de estas técnicas es el
análisis Pratt \parencite{pratt-parsing-paper}
\parencite{pratt-parsing-example}, que representa los niveles de precedencia con
funciones para comparar operadores. Gracias a esto, se puede evitar representar los niveles de
precedencia en la propia \gls{grammar}, permitiendo utilizar una representación
más natural de la \gls{grammar}.

\subsection{Análisis ascendente}

Dentro de los analizadores ascendentes, existen muchas técnicas distintas. La
mayoría de estas técnicas pertenecen a la familia LR, como SLR, LALR, o GLR.
Todas las técnicas en esta subfamilia utilizan un algoritmo similar: cuentan con
una pila inicialmente vacía y un autómata finito (representado por una tabla)
que, según su estado, determina su siguiente estado y la operación a aplicar a
la entrada y pila. Esta operación puede ser añadir un símbolo de la entrada a la
cima de la pila o agrupar los últimos símbolos de la pila en un símbolo no
terminal según una producción determinada. La diferencia entre estos métodos
está en cómo se construye el autómata finito y el conjunto de \glspl{grammar}
que pueden representar, siendo SLR un método simple que puede representar pocas
\gls{grammar}, mientras que LALR puede representar más \glspl{grammar}, pero es
más complejo de construir. \parencite{dragon-book} GLR es una generalización de
las técnicas LR para permitir procesar \glspl{ambiguous grammar}
\parencite{GLR-algorithm}.

Debido a la gran cantidad de estados que puede tener el autómata, estos
analizadores típicamente se contruyen automáticamente a partir de la
\gls{grammar} con un generador de \glspl{parser} \parencite{dragon-book}.
Existen muchas herramientas de este tipo como Lex y yacc \parencite{yacc}
(basado en LALR), sus versiones modernas de GNU Flex y bison \parencite{bison}
(basado en LALR por defecto, aunque pueden utilizar GLR), o Tree-sitter
\parencite{tree-sitter} (basado en GLR).
