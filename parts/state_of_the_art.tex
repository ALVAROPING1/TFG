\chapter{Estado del arte}\label{chap:state-of-the-art}
% TODO:
% - RISCV/ARM/MIPS
% - Simuladores de ensamblador
%   - Sail/Creator
% - GNU as/intel (no estandarizado)/TCCASM
% - Lenguajes en los que se implementan compiladores
% - WASM/JS
% - NPM/cargo

\section{Mensajes de error}

En la actualidad, los mensajes de error de los \gls{compiler} tienen muchas
formas y calidades. Un \gls{compiler} con buenos mensajes de error puede ayudar
mucho a solucionar los problemas más rápidamente, ya que permite obtener toda la
información necesaria para solucionar el problema del propio mensaje de error.

Un ejemplo de malos mensajes de error es el \gls{compiler} de C\#, cuyos mensajes
de error se pueden ver en la \figureref{error_csharp}. Como se puede ver, estos
mensajes contienen muy poca información sobre el problema. Esto dificulta
corregir los errores, especialmente para alguien que está intentando aprender el
lenguaje.

\graphicfigure[0.9]{error_csharp}{Mensaje de error del compilador de C\#}

Actualmente, el compilador de Rust \parencite{Rust} es uno de los
compiler que mejores mensajes de error genera. La \figureref{error_rust}
muestra un ejemplo de estos mensajes, obtenido en un caso de uso real. Como se
puede observar, este mensaje cuenta con varios componentes importantes:

\begin{itemize}
    \item Un mensaje de error con una explicación clara del error.
    \item La localización en el código que ha producido el fallo.
    \item Información adicional sobre el error y su causa, resaltada sobre el
    propio código.
    \item Un mensaje de ayuda que indica una posible solución del error,
    incluyendo una explicación y las modificaciones necesarias resaltadas sobre
    el código.
    \item Una forma de acceder a una explicación detallada sobre el problema.
\end{itemize}

Además de esto, la información está resaltada con diversos colores e indicadores
y se deja cierto espacio en blanco para separar las diferentes partes, lo cual
ayuda a leer rápidamente la información más importante para solucionar el
problema y filtrar la que no se necesita.

\graphicfigure[0.9]{error_rust}{Mensaje de error del compilador de Rust}

\FloatBarrier

\section{Técnicas de análisis sintáctico}\label{sec:parser-techniques}

Un \gls{compiler} se compone principalmente de dos partes: análisis sintáctico y
análisis semántico. El análisis sintáctico (\textit{parsing}) se encarga de
transformar el código a una representación intermedia, mientras que el análisis
semántico se encarga de, utilizando la representación intermedia, verificar que
el \gls{program} cumple la semántica del lenguaje y generar el código compilado.
\parencite{dragon-book}

Al tratar con la semántica del lenguaje, no existen técnicas generales para
realizar el análisis semántico. Sin embargo, para realizar el análisis
sintáctico, existen múltiples técnicas basadas en el uso de \glspl{grammar}
libres de contexto. Una \gls{grammar} es una descripción formal de la sintáxis
de un lenguaje, y está formada por: \parencite{dragon-book}

\begin{itemize}
    \item Un conjunto de símbolos terminales (también conocidos como
    \glspl{token}), que representan los símbolos que pueden aparecer en las
    cadenas del lenguaje.
    \item Un conjunto de símbolos no terminales, que representan estructuras
    sintácticas del lenguaje (conjuntos de cadenas).
    \item Un símbolo no terminal denominado axioma, que representa todas las
    cadenas del lenguaje.
    \item Un conjunto de producciones, que representan las reglas según las
    cuales un símbolo no terminal se puede reemplazar por una secuencia de
    símbolos terminales y/o no terminales.
\end{itemize}

Una gramática genera cadenas de caracteres aplicando las producciones a una
secuencia de símbolos, empezando por el axioma y continuando hasta que la
secuencia de símbolos solo contenga símbolos terminales. Este proceso se puede
representar con un árbol síntáctico, en el cual los nodos representan símbolos
(siendo la raíz el axioma, los \glspl{internal node} símbolos no terminales, y
las \glsdisp{leaf node}{hojas} símbolos terminales), y las relaciones entre un
nodo y sus hijos representan la aplicación de una producción determinada. La
tarea de un analizador sintáctico (\gls{parser}) consiste en determinar el árbol
sintáctico que produce la cadena de entrada. \parencite{dragon-book}

Las técnicas para realizar el análisis sintáctico se pueden agrupar en dos
grandes familias: análisis descendence (\textit{top-down}) y análisis ascendente
(\textit{bottom-up}). La diferencia entre estas familias está en cómo generan el
árbol sintáctico. Un analizador descendente empieza por la raíz (axioma) y
determina las producciones que se tienen que aplicar para obtener la cadena de
entrada, realizando una búsqueda en profundidad. Un analizador ascendente, en
cambio, empieza con los nodos hoja del árbol y determina cómo agruparlos en
símbolos no terminales siguiendo las producciones hasta llegar a la raíz.
\parencite{dragon-book}

\subsection{Análisis descendente}

Dentro de los analizadores descendentes, la técnica más general y utilizada es
el análisis descendente recursivo, que consiste en un programa que modela la
\gls{grammar} mediante un conjunto de funciones mutuamente recursivas, cada una
de las cuales representa un símbolo no terminal. Analizando la \gls{grammar}, se
puede crear un analizador predictivo en el cual el siguiente símbolo de la
entrada a procesar permite determinar sin ambigüedades el flujo de control en
cada función. \parencite{dragon-book}

Gracias a su sencillez, esta técnica típicamente se implementa a mano, aunque
también existen herramientas como ANTLR \parencite{ANTLR} que permiten generar
un analizador automáticamente a partir de una \gls{grammar} (conocido como
generador de \glspl{parser} \parencite{dragon-book}).

También existen otros métodos para crear analizadores descendentes
recursivos a partir de una \gls{grammar}, como los combinadores de
\glspl{parser}. Este método consiste en definir un analizador sintáctico como
combinación de otros \glspl{parser} más simples, utilizando diversos operadores
que permiten realizar combinaciones muy expresivas
\parencite{parser-combinators}. En la actualidad, existen muchas bibliotecas que
cuentan con estos operadores ya implementados, como Parsec \parencite{parsec}, Chumsky
\parencite{chumsky}, y pom \parencite{pom}.

% TODO: maybe mention resilient LL parsing?
La principal ventaja de crear un analizador descendente recursivo manualmente es su
gran flexibilidad, ya que ofrece control total sobre el funcionamiento del
analizador sintáctico. Esto permite utilizar información obtenida durante la
ejecución del \gls{compiler} para decidir cómo procesar la entrada, permitiendo
un cierto grado de sensibilidad al contexto. Además, esto ayuda a generar buenos
mensajes de error y a aplicar estrategias de recuperación de errores
\parencite{errors-clang}. Muchos de los \glspl{programming language} utilizados
en la actualidad, como C y C++, utilizan este método
\parencite{parser-types-survey}.

El principal problema de crear un analizador descendente recursivo a mano es su
complejidad, requiriendo mucho tiempo para su desarrollo, además de que las
modificaciones de la \gls{grammar} también son complicadas. Los combinadores de
\glspl{parser}, en cambio, facilitan mucho estos procesos, aunque sacrifican un
poco de rendimiento para lograrlo. Esto hace que los combinadores de
\glspl{parser} sean un método ideal para realizar prototipos, durante los cuales
la \gls{grammar} puede variar, mientas que crear un analizador manualmente es
una mejor opción para un producto final cuando el rendimiento se vuelve un
problema.

\subsection{Análisis ascendente}

Dentro de los analizadores ascendentes, existen muchas técnicas distintas. La
mayoría de estas técnicas pertenecen a la familia LR, como SLR, LALR, o GLR.
Todas las técnicas en esta subfamilia utilizan un algoritmo similar: cuentan con
una pila inicialmente vacía y un autómata finito (representado por una tabla)
que, según su estado, determina su siguiente estado y la operación a aplicar a
la entrada y pila. Esta operación puede ser añadir un símbolo de la entrada a la
cima de la pila o agrupar los últimos símbolos de la pila en un símbolo no
terminal según una producción determinada. La diferencia entre estos métodos
está en cómo se construye el autómata finito y el conjunto de \glspl{grammar}
que pueden representar, siendo SLR un método simple que puede representar pocas
\gls{grammar}, mientras que LALR puede representar más \glspl{grammar}, pero es
más complejo de construir. \parencite{dragon-book} GLR es una generalización de
las técnicas LR para permitir procesar \glspl{ambiguous grammar}
\parencite{GLR-algorithm}.

Debido a la gran cantidad de estados que puede tener el autómata, estos
analizadores típicamente se contruyen automáticamente a partir de la
\gls{grammar} con un generador de \glspl{parser} \parencite{dragon-book}.
Existen muchas herramientas de este tipo como Lex y yacc \parencite{yacc}
(basado en LALR), sus versiones modernas de GNU Flex y bison \parencite{bison}
(basado en LALR por defecto, aunque pueden utilizar GLR), o Tree-sitter
\parencite{tree-sitter} (basado en GLR).

% TODO: maybe extract into a "mixed" section?
Estas técnicas, en general, son muy efectivas. Sin embargo, para \glspl{grammar}
que cumplen ciertas propiedades (\glspl{operator-precedende grammar}) típicas de
\gls{expression} aritméticas con muchos niveles de precedencia, existen técnicas
más eficientes. Estas técnicas se pueden agrupar en los \gls{parser} de
precedencia de operadores \parencite{operator-precedence-parser}. Un ejemplo de
estas técnicas es el análisis Pratt \parencite{pratt-parsing-paper}
\parencite{pratt-parsing-example}, que representa los niveles de precedencia
con funciones para comparar operadores y utiliza esta información para
desambiguar la \gls{grammar}.
